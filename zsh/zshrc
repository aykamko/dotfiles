# vim: set ft=zsh:
###############################################################################
# Prezto
###############################################################################
# redraw prompt on async prompt callback signal
function TRAPUSR1 {
  _async_prompt_pid=0
  _async_prompt=$(cat $HOME/._async_prompt)
  zle && zle .reset-prompt
}

# run compinit -S on trusted computers
export TRUSTED_COMPINIT="HAL 9000"

# don't load prezto outside of tmux to speed up load
[[ -n $TMUX ]] || [[ -f "$HOME/.no_tmux" ]] && \
  [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]] && source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"

for keymap in 'emacs' 'viins'; do
  bindkey -M "$keymap" "$key_info[Control]P" history-substring-search-up
  bindkey -M "$keymap" "$key_info[Control]N" history-substring-search-down
done

# make Escape in vicmd mode do nothing
unset BEEP
bindkey -M vicmd '\e' beep

# load shell bookmarks
if [[ -f $HOME/.config/shell_bookmarks.zsh ]]; then
  source $HOME/.config/shell_bookmarks.zsh
fi
alias bookmarks="vim $HOME/.config/shell_bookmarks.zsh"

###############################################################################
# Neovim Pane Switching
###############################################################################
# vim
if (( $+commands[nvim] )); then
  alias vim=nvim
  alias vi=nvim
else
  alias vi=vim
fi

# only defined in neovim libvterm
if [[ -n $NVIM_LISTEN_ADDRESS ]]; then

  _nvr_up()    { nvr -c 'TmuxNavigateUp' }
  _nvr_right() { nvr -c 'TmuxNavigateRight' }
  _nvr_down()  { nvr -c 'TmuxNavigateDown' }
  _nvr_left()  { nvr -c 'TmuxNavigateLeft' }
  zle -N nvr_up _nvr_up
  zle -N nvr_right _nvr_right
  zle -N nvr_down _nvr_down
  zle -N nvr_left _nvr_left
  bindkey '^K' nvr_up
  bindkey '^L' nvr_right
  bindkey '^J' nvr_down
  bindkey '^H' nvr_left

  sp () { nvr -o $@ }
  vsp () { nvr -O $@ }
  ds() { nvr -c "DirectionalSplit $@" }

  alias nvim=nvr
  alias vim=nvr
  alias vi=nvr
  export EDITOR=nvr

  command_not_found_handler() {
    if [[ "$@" =~ ^: ]]; then
      nvr --remote-send "<C-\\><C-n>${@}<CR>"
    else
      return 127
    fi
  }

  fe() { nvr --remote-send "<esc><esc>:GitFZF $PWD<cr>" }

elif [[ -n $TMUX ]]; then
  alias ':q'='tmux kill-pane'
fi

###############################################################################
# Aliases & Functions
###############################################################################
# basics
alias restart="exec $SHELL"
alias c=clear
clr() {
  clear
  [[ -n $TMUX ]] && tmux clear-history
}
stripansi() {
  [[ $UNAME == darwin ]] && \
    sed -E "s/"$'\E'"\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g" ||
    sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g"
}
word() {
  awk "{print \$$1}"
}

alias cm='command'

alias rrm='command rm'

alias unixtime='date +%s'

alias vimrc='vim ~/.vimrc'
alias vis='vim -u ~/.vim/vimrc_small'
alias vimrc_small='vis ~/.vim/vimrc_small'

vim-profile() {
  $DOTFILES/vim-profiler/vim-profiler.py ${@:1:$((${#@} - 1))} $(which nvim) ${@: -1}
}

swpclean() {
  find . -name '*.sw*' -exec /bin/rm -rf {} \;
}

vimreplace() {
  [[ $# < 2 ]] && echo 'Not enough arguments' && return

  local search
  (( $+commands[ag] )) && \
    search="ag -l --nocolor $1" || \
    search="grep -rl $1 *"

  local -a matches
  while read line; do
    matches+=$line
  done < <(eval $search)

  # eventignore magic from http://stackoverflow.com/a/12487439
  vim -c "bufdo set eventignore-=Syntax | %s/$1/$2/gec | update" ${matches}
}

# zsh
alias zshso='source ~/.zshrc'
alias zshenv='vim ~/.zshenv'
alias zshrc='vim ~/.zshrc'
alias zprofile='vim ~/.zprofile'
alias zpreztorc='vim ~/.zpreztorc'
alias zlogin='vim ~/.zlogin'
alias zlocal='vim ~/.zshrc.local'

# git
alias gitconfig='vim ~/.gitconfig'
alias gitignore_global='vim ~/.gitignore_global'
alias gs='git status'
rg_git_list() {
  # lists all files in a git repository, marking ignored files as yellow
  local root is_git_dir
  if [[ -n $1 ]]; then
    root=$1
    is_git_dir=1
  else
    root=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ $? -eq 0 ]]; then
      is_git_dir=1
    else
      is_git_dir=0
      root=$PWD
    fi
  fi

  local rg_args_inverse_git_ignore=()
  if [[ $is_git_dir -eq 1 && -f $root/.gitignore ]]; then
    cat $root/.gitignore | while read rule; do
      rule=${rule%%\#*}
      [[ -n $rule ]] && rg_args_inverse_git_ignore+=("-g '$rule'")
    done
  fi

  local ylw=$(tput setaf 3)
  local clr=$(tput sgr0)
  {
    # regular files
    chdir $root && rg -g '!.git' --hidden --files;

    # gitignored files
    if [[ $is_git_dir -eq 1 && -f $root/.gitignore ]]; then
      chdir $root && eval "rg --no-ignore-vcs ${rg_args_inverse_git_ignore[@]} --files" | \
        while read match; do echo -e "$ylw$match$clr"; done;
    fi;
  }
}

# tmux
alias t='tmux'
alias tl='tmux ls'
alias detach='tmux detach'
alias tmuxconf="vim ~/.tmux.conf"
alias tconf='tmuxconf'
alias tname='tmux rename-session'
tswap() {
  tmux swap-window -t $1
}
notmux() {
  touch ~/.no_tmux
}
if [[ -z $TMUX ]]; then
  tmux() { [[ -z "$@" ]] && command tmux new -A -s main || command tmux "$@" }
fi

tkill() {
  case $1 in
    (-1)
      command tmux kill-session;;
    (-a|--all)
      command tmux kill-session -a;;
    (*)
      command tmux kill-session -a
      command tmux kill-session;;
  esac
}

# CSV
# source: https://chrisjean.com/view-csv-data-from-the-command-line/

csvless() {
  local outputcmd
  if [[ -n $2 ]]; then
    outputcmd="head -n $2"
  else
    outputcmd="cat"
  fi
  eval "$outputcmd $1" | sed -e 's/,,/, ,/g' | column -s, -t | less -#5 -N -S
}

# julia
alias jl=julia

# python
alias ipy3=ipython3
alias ipy=ipython2
alias py=python
alias py3=python3
venv() {
  source $1/bin/activate
}
rpdb() {
  socat readline tcp:${2:-0.0.0.0}:${1:-4444}
}

ctags() {
  unset -f ctags && \
    brew list ctags >/dev/null 2>&1 && \
    alias ctags="$(brew --prefix)/bin/ctags"
  ctags "$@"
}
# re-activate any active VIRTUAL_ENV on shell start up
if [[ -n $VIRTUAL_ENV ]]; then
  source ${VIRTUAL_ENV}/bin/activate
fi

# re-activate any active anaconda env on shell start up
if [[ -n $CONDA_DEFAULT_ENV ]]; then
  echo "Sourcing conda env: $CONDA_DEFAULT_ENV"
  source activate $CONDA_DEFAULT_ENV
fi

# modified from http://unix.stackexchange.com/questions/13464
upsearch() {
  local curdir="$PWD"
  while 1; do
    [[ -f "$curdir/$1" ]] && echo "$curdir/$1" && return
    [[ $curdir == "/" ]] && return
    curdir=$(dirname "$curdir")
  done
}
dmake() { # django
  local django=$(upsearch manage.py)
  [[ -n $django ]] && \
    (cd $(dirname $django) && python $django "$@") || \
    echo "Couldn't find manage.py"
}

# ruby
if (( $+commands[rbenv] )); then
  rbenv() { unset -f rbenv && eval "$(rbenv init - | tail -n +2)" && rbenv "$@"; }
fi

if (( $+commands[nodenv] )); then
  nodenv() { unset -f nodenv && eval "$(nodenv init - | tail -n +2)" && nodenv "$@"; }
fi

# if (( $+commands[pyenv] )); then
#   pyenv() { unset -f pyenv && eval "$(pyenv init - | tail -n +2)" && pyenv "$@"; }
# fi

# git
alias g='git'

# context from root of git directory
gr() {
  local root=$(command git rev-parse --show-toplevel 2> /dev/null)
  [[ $? == 0 ]] && cd $root || cd "$@"
}
alias '$'=gr

if (( $+commands[tag] )); then
  tag() { command tag "$@"; source ${TAG_ALIAS_FILE:-/tmp/tag_aliases} 2>/dev/null }
  alias ag=tag
fi
# if (( $+commands[peco] )); then
#   tag() { nvim $(rg -n $1 | peco | awk -F\: '{print "+"$2,$1}') }
#   # alias ag=tag
# fi

# other
alias tmp="cd $HOME/tmp"
alias texclean='rm -rf *.aux *.fdb_latexmk *.fls *.log *.synctex.gz 2>/dev/null'

# NOTE: overrides unix `last` command, but that's not too useful anyway
last() {
  [[ -z $TMUX && -z $NVIM_LISTEN_ADDRESS ]] && echo 'Sorry, not in tmux or nvim. :(' && return

  local prev_cmd
  prev_cmd=$(fc -ln -1 | sed -e 's/[\/&]/\\&/g')

  local last_out=$TMPDIR/last.$$
  if [[ -n $NVIM_LISTEN_ADDRESS ]]; then
    nvr -c "w! $last_out" >/dev/null
  else
    tmux capture-pane -pe -S - >! $last_out
  fi

  tail -r $last_out | awk "/$PROMPT_DELIM/{p=!p;if(p){next}else{exit}} p" | tail -r
}
if (( $+commands[fpp] )); then
  alias lp='last | fpp'
fi

psag() {
  ps aux | ag "[${1[1]}]${1[2,-1]}"
}

pskill() {
  ps aux | ag "[${1[1]}]${1[2,-1]}" | awk '{print $2}' | sudo xargs -I% command kill ${2:-} %
}

###############################################################################
# Builtin overrides
###############################################################################
if [[ $UNAME == darwin ]]; then
  alias fancyls="ls -G"
else
  alias fancyls="ls --group-directories-first --color=auto"
fi

# override cd to do ls and vim when necessary
better_cd() {
  set -- ${1//,/.} # replace commas , with periods . (looking at u Golang)
  if [[ -f $1 ]]; then
    local fdir=$(dirname $1)
    [[ -d $fdir ]] && builtin cd $fdir && fancyls && vim $(basename $1) ${*:2}
  else
    builtin cd "$@" && fancyls
  fi
}
alias cd=better_cd

# tab completion in dotfiles directory
dotfiles() { cd $DOTFILES/$1; }
compctl -f -W $DOTFILES/ dotfiles

###############################################################################
# Special Settings
###############################################################################
[[ -f "$HOME/.zshrc.os" ]] && source "$HOME/.zshrc.os"         # OS Specific
[[ -f "$HOME/.zshrc.local" ]] && source "$HOME/.zshrc.local"   # Local
[[ -f "$HOME/.secret_zshrc" ]] && source "$HOME/.secret_zshrc" # Secret!

###############################################################################
# z
###############################################################################
[[ -f $DOTFILES/z/z.sh ]] && source $DOTFILES/z/z.sh

###############################################################################
# vim fzf
###############################################################################
if [[ -f ~/.fzf.zsh ]]; then
  source ~/.fzf.zsh
  export FZF_COMPLETION_TRIGGER='jk'

  export FZF_DEFAULT_COMMAND="$(which rg_git_list); rg_git_list"
  export FZF_CTRL_T_COMMAND=$FZF_DEFAULT_COMMAND

  export FZF_DEFAULT_OPTS='--ansi -x -m --bind=alt-k:up,alt-j:down'
  bindkey '^F' fzf-file-widget
fi

###############################################################################
# direnv
###############################################################################
# TODO(aleks, 08/13/17): too slow
# if (( $+commands[direnv] )); then
#   eval "$(direnv hook zsh)"
# fi

###############################################################################
# zsh scripts
###############################################################################
if [[ -d $DOTFILES/zsh/scripts ]]; then
  for f in $DOTFILES/zsh/scripts/*; do
    source $f
  done
fi

unsetopt CORRECT         # disable autocorrect suggestions for commands
unsetopt AUTO_NAME_DIRS  # don't resolve environment variables in prompt
setopt NO_NOMATCH        # pass bad match to command

# disable ctrl-d to logout
setopt IGNORE_EOF
bindkey -r '^D'
bindkey '^A' beginning-of-line
bindkey '^E' end-of-line

# don't warn when overwriting existing file
setopt clobber

if [[ -o INTERACTIVE && ! -o LOGIN ]]; then
  _startup_time_prompt '\x1b[35m'  # purple
fi
