" vim:sw=2:sts=2:ts=2:et:
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" {{{ vim-plug
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if has('vim-starting')
  set encoding=utf-8 " necessary to show Unicode glyphs
end
if !has('nvim')
  set nocompatible   " be iMproved
end
let s:darwin = has('mac')
let s:tmux = $TMUX != ''
function! s:SID()
  return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
endfunction

augroup vimrc_folding
  autocmd!
  autocmd BufNewFile,BufReadPost .vimrc
        \  set foldmethod=marker
        \| set foldlevel=0
        \| autocmd! vimrc_folding
augroup END

" autoinstall vim-plug
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall
endif

let g:plug_dir = '~/.vim/bundle/'

call plug#begin(g:plug_dir)

" Plug 'neomake/neomake'
" Plug 'w0rp/ale' | Plug 'maximbaz/lightline-ale'
Plug 'sbdchd/neoformat'
Plug 'christoomey/vim-tmux-navigator'
Plug 'itchyny/lightline.vim'
Plug 'junegunn/vim-easy-align'
Plug 'kana/vim-textobj-user'
Plug 'nathanaelkane/vim-indent-guides'
Plug 'tomtom/tcomment_vim'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-fugitive' | Plug 'tpope/vim-rhubarb'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-surround'
Plug 'wellle/targets.vim'
Plug 'junegunn/vim-peekaboo'
" Plug '/Users/aleks/proj/vim-touchbar'
" Plug 'sheerun/vim-polyglot', { 'for': ['Jenkinsfile', 'groovy'] }
Plug 'jceb/vim-orgmode'
      \ | Plug 'tpope/vim-speeddating'
Plug 'blueyed/vim-diminactive'
Plug 'neoclide/coc.nvim', { 'branch': 'release' }
" Plug 'wakatime/vim-wakatime'  " this plugin is way too slow unfortunately

if has('nvim')
 Plug 'phaazon/hop.nvim'
else
 Plug 'easymotion/vim-easymotion'
       \ | Plug 'aykamko/vim-easyoperator-line'
       \ | Plug 'aykamko/vim-easymotion-segments'
endif
Plug 'mattn/webapi-vim'
      \ | Plug 'mattn/gist-vim', { 'on': 'Gist' }
Plug 'junegunn/goyo.vim',        { 'on': 'Goyo' }

Plug 'HerringtonDarkholme/yats.vim', { 'for': ['typescript', 'typescript.tsx', 'typescriptreact'] }
Plug 'othree/yajs.vim',              { 'for': 'javascript' }
Plug 'vim-ruby/vim-ruby',            { 'for': 'ruby' }
" Plug 'Glench/Vim-Jinja2-Syntax',     { 'for': 'jinja' }
Plug 'fatih/vim-go',                 { 'for': 'go' }
Plug 'aykamko/vim-python-pep8-indent',{ 'for': 'python' }
Plug 'kchmck/vim-coffee-script',     { 'for': 'coffee' }
Plug 'lervag/vimtex',                { 'for': 'tex' }
" Plug 'mattn/emmet-vim',              { 'for': ['jinja', 'html'] }
" Plug 'nono/vim-handlebars',          { 'for': ['jinja', 'html'] }
Plug 'vim-scripts/sh.vim--Cla',      { 'for': ['sh', 'zsh', 'bash'] }
Plug 'jez/vim-github-hub',           { 'for': 'markdown.ghpull' }
Plug 'derekwyatt/vim-scala',         { 'for': 'scala' }
Plug 'tweekmonster/django-plus.vim'

augroup terraform_filetype
  autocmd!
  autocmd BufNewFile,BufReadPost *.tf set filetype=terraform
  autocmd BufNewFile,BufReadPost *.hcl set filetype=terraform
  autocmd BufNewFile,BufReadPost *.tfstate set filetype=json
  autocmd VimEnter * if PlugLoaded('tcomment_vim')
        \| call tcomment#type#Define('terraform', '# %s') | endif
augroup END
Plug 'hashivim/vim-terraform',       { 'for': ['terraform', 'hcl'] }

augroup slim_filetype
  autocmd!
  autocmd BufNewFile,BufReadPost *.slim set filetype=slim
augroup END
Plug 'slim-template/vim-slim',       { 'for': 'slim' }

" augroup jsx_filetype
"   autocmd!
"   autocmd BufNewFile,BufReadPost *.jsx set filetype=javascript.jsx
" augroup END
Plug 'pangloss/vim-javascript'
Plug 'MaxMEllon/vim-jsx-pretty'

if has('nvim')
  " Plug 'mhartington/nvim-typescript', {
  "       \ 'for': ['typescript', 'typescript.tsx'],
  "       \ 'do': ['./install.sh', ':UpdateRemotePlugins'] }
  " Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
  " Plug 'zchee/deoplete-jedi', { 'for': 'python' }
  " Plug '~/proj/deoplete-foreign-buffer.nvim'
  " Plug 'euclio/vim-markdown-composer', { 'for': 'markdown' }
  Plug 'Shougo/neosnippet.vim'
  Plug 'Shougo/defx.nvim', { 'do': ':UpdateRemotePlugins' }
endif

if has('mac')
  Plug 'junegunn/vim-xmark', { 'do': 'make' }
endif

Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': 'yes \| ./install' }
Plug 'junegunn/fzf.vim'

function! s:gitroot(...)
  let from_dir = a:0 ? a:1 : expand('%:p:h')
  let gitroot = system('git -C '.from_dir.' rev-parse --show-toplevel')
  if !v:shell_error
    return substitute(gitroot, '\n\+$', '', 'g').'/'
  endif
endfunction
command! -nargs=? Groot echo s:gitroot(<f-args>)

let g:gitroot = s:gitroot()
if executable(g:gitroot.'bin/rails') || executable(g:gitroot.'script/rails')
  Plug 'tpope/vim-rails', { 'for': 'ruby' }
end

call plug#end()
filetype plugin indent on " required

function! PlugLoaded(plug_name) abort
  return !empty(get(g:plugs, a:plug_name)) && isdirectory(g:plugs[a:plug_name]['dir'])
endfunction
command! -nargs=1 PlugLoaded echo PlugLoaded(<f-args>)

if !empty(gitroot)
  exec 'cd '.gitroot
end

function! s:strip_trailing(str) abort
  return substitute(substitute(a:str, '^[\n\s]\+', '', ''), '[\n\s]\+$', '', '')
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" General Settings {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let mapleader = ' '
let maplocalleader = ' '

let s:E = '✖ '
let s:W = '▲ '
let s:WAIT = '...'
let s:OK = '✓'

" workaround for pyenv
" let g:python_version = matchstr(system("python --version 2>&1 | cut -f2 -d' '"), '^[0-9]')
" if g:python_version =~ 3
function! s:pick_first_executable(...)
  for path in a:000
    if executable(path)
      return path
    endif
  endfor
endfunction
let g:python_host_prog = s:pick_first_executable(
      \ '/Users/aleks/.pyenv/shims/python',
      \ '/usr/local/bin/python2',
      \ '/usr/bin/python2')
let g:python3_host_prog = s:pick_first_executable(
      \ '/Users/aleks/.pyenv/shims/python3',
      \ '/usr/local/bin/python3',
      \ '/usr/bin/python3')

" skip checks
let g:python_host_skip_check = 1
let g:python3_host_skip_check = 1

" Display
set ruler           " show cursor position
set nolist          " hide tabs and EOL chars
set showcmd         " show normal mode commands as they are entered
set noshowmode      " don't show mode becase powerline already does it
set nowrap          " don't wrap long lines
set hidden          " don't warn unsaved changes when changing buffers

" Scrolling
set scrolloff=5     " minimum of three lines above and below cursor
set scrolljump=5    " scroll five lines at a time vertically
set sidescroll=10   " minumum columns to scroll horizontally

" Search
set nohlsearch      " persist search highlighting, initially
set incsearch       " search with typeahead

" Indent
set autoindent      " carry indent over to new lines

" Clipboard
set clipboard=unnamed " set unnamed to copy to system clipboard

" Mouse
set mouse=a           " enable mouse movement

" Backups
set backupdir=/tmp//,.
set directory=/tmp//,.
if v:version >= 703
  set undodir=/tmp//,.
endif

" Other
set noerrorbells      " no bells in terminal

" Autoreload if file changes on disk
set autoread
augroup autoread
  autocmd!
  autocmd CursorHold,WinEnter,FocusGained * checktime
augroup END

set tags=.git/tags,tags;/       " search up the directory tree for tags

set undolevels=1000   " number of undos stored
if has('nvim')
  set shada='100,<1000,s100,n$HOME/.nvim.shada
else
  set viminfo='50,"50   " '=marks for x files, "=registers for x files
endif

if has('nvim')
  augroup delete_terminal_buffers_on_hide
    autocmd!
    autocmd TermOpen * setlocal bufhidden=delete
  augroup END
end

let s:buftype_hide_columns = ['terminal', 'defx']
function! s:should_show_columns_for_buftype() abort
  return index(s:buftype_hide_columns, &ft) < 0
endfunction

" hack to always display sign column
augroup always_display_sign_col
  autocmd!
  autocmd BufEnter * sign define dummy
  autocmd BufEnter * if <SID>should_show_columns_for_buftype() |
        \ exec 'sign place 9999 line=1 name=dummy buffer='.bufnr('') |
        \ endif
  if has('nvim')
    " no sign column in terminals pls
    autocmd TermOpen * exec 'sign unplace * buffer='.bufnr('')
  endif
augroup END

" remove small delay when leaving insert mode
if !has('nvim') && !has('gui_running')
  set ttimeoutlen=10
  augroup fast_escape
    autocmd!
    autocmd InsertEnter * set timeoutlen=0
    autocmd InsertLeave * set timeoutlen=1000
  augroup END
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Colorscheme {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if $TERM_PROGRAM == 'iTerm.app' && has('nvim') && empty($SSH_CLIENT) " mosh doesn't support 24-bit color
  set termguicolors
endif
syntax enable

set background=dark
try
  colorscheme hybrid_ayk
catch /:E185:/
  " silently ignore if colorscheme not found
endtry

set lazyredraw

function! GetHiKey(group, key)
  redir => highlight_output
  exec "silent highlight ".a:group
  redir END
  for key_val in split(highlight_output)
    if key_val =~ '^'.a:key
      return key_val[(len(a:key) + 1):]
    endif
  endfor
endfunction
function! RGBtoHex(r, g, b)
  return join(['#', printf('%.2x', a:r), printf('%.2x', a:g), printf('%.2x', a:b)], '')
endfunction
function! Adjust(color, amount)
  let color = (a:color[0] == '#') ? a:color[1:] : a:color
  if type(a:amount) == 5  " float
    let amount = a:amount
  else
    let amount = (a:amount / 100.0)
  endif
  let adj = float2nr(255 * amount)
  let r = max([str2nr(color[0:1], 16) + adj, 0])
  let g = max([str2nr(color[2:3], 16) + adj, 0])
  let b = max([str2nr(color[4:5], 16) + adj, 0])
  return RGBtoHex(r, g, b)
endfunction
function! Darken(color, amount)
  return Adjust(a:color, -a:amount)
endfunction
function! Lighten(color, amount)
  return Adjust(a:color, a:amount)
endfunction

" adjust colorcolumn
exec 'highlight! ColorColumn ctermbg=235 guibg='.
      \ Darken(GetHiKey('Normal', 'guibg'), 0.015)

let g:colorcolumn_blacklist = ['qf']
augroup display_colorcolumn
  autocmd!
  autocmd Filetype *
        \ if index(g:colorcolumn_blacklist, &ft) < 0 |
        \ setlocal colorcolumn=79,80,99,100,119,120 |
        \ endif
augroup END

" adjust Search highlighting
exec 'highlight! Search guifg=NONE guibg='.
      \ Lighten(GetHiKey('Normal', 'guibg'), 10)

" change vim split line color to differentiate from tmux
exec 'highlight! StatusLineNC ctermfg=5 guifg='.g:terminal_color_5
exec 'highlight! VertSplit ctermfg=5 guifg='.g:terminal_color_5

" add some extra keywords to Todo highlight group
augroup extra_todo_highlights
  autocmd!
  autocmd Syntax * syn match highlightKeywords
        \ /\v ?<(BEGIN|END|HACK|XXX|INFO|BUG|NOTE|TODO|NOPUSH)(\([^)]*\))?/
        \ containedin=.*Comment.*
augroup END
highlight! def link highlightKeywords Todo
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Line Numbering {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" toggle number/relativenumber on insert/normal mode
function! s:insert_toggle_relnumber()
  if !get(b:, 'goyo_enabled', 0) && <SID>should_show_columns_for_buftype()
    setlocal invrelativenumber
  endif
endfunction

augroup line_numbering
  autocmd!
  autocmd BufEnter * if <SID>should_show_columns_for_buftype() |
                          \ setlocal number | setlocal relativenumber |
                          \ endif
  autocmd BufLeave * if <SID>should_show_columns_for_buftype() |
                          \ setlocal number | setlocal norelativenumber |
                          \ endif
  autocmd InsertEnter,InsertLeave * call s:insert_toggle_relnumber()
  if has('nvim')
    autocmd TermOpen * setlocal norelativenumber | setlocal nonumber
  endif
augroup END

augroup focus_events_line_numbering
  autocmd!
  autocmd FocusLost * call s:insert_toggle_relnumber() |
        \ autocmd FocusGained,FocusLost * call s:insert_toggle_relnumber() |
        \ autocmd! focus_events_line_numbering
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Indentation {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set shiftwidth=8
set tabstop=4
set softtabstop=4
set expandtab
set backspace=indent,eol,start
set textwidth=99
augroup modify_textwidth
  autocmd!
  autocmd FileType sh,bash,zsh set textwidth=79
augroup END
let g:is_posix = 1  " always use posix syntax

" vim-indent-guides
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_auto_colors = 0
let g:indent_guides_start_level = 2
hi! IndentGuidesOdd ctermbg=NONE guibg=NONE
exec 'hi! IndentGuidesEven ctermbg=234 guibg='.Darken(GetHiKey('Normal', 'guibg'), 0.015)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Commands/Mappings {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" remap j/k for wrapped lines; add relative jumps to jumplist
" Source: reddit.com/r/vim/comments/3npf1z/using_jk_for_wrapped_lines_and_adding_jk_with_a/cvq2k3x
function! s:linemotion(dir)
  return (v:count1 > 1 ? "m'".v:count1 : 'g').a:dir
endfunction
nnoremap <silent><expr> j <SID>linemotion('j')
nnoremap <silent><expr> k <SID>linemotion('k')
vnoremap <silent><expr> j <SID>linemotion('j')
vnoremap <silent><expr> k <SID>linemotion('k')

" makes sense
nnoremap <silent> Y yg_
nnoremap <silent> yY ^yg_
nnoremap <silent> dD ^D
nnoremap <silent> cC ^C
nnoremap <silent> K i<Enter><Esc>^

" Use <C-a> to go to from of command line
cnoremap <C-a> <C-b>

" because I suck
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev X x
cnoreabbrev WQ wq
cnoreabbrev Wq wq
cnoreabbrev wQ wq
cnoreabbrev Qa qa

" Easily move to start/end of line
nnoremap H 0
vnoremap H 0
nnoremap L $
vnoremap L $

" move screen by a:cols_dt columns
function! s:horizontal_scroll(cols_dt)
  if a:cols_dt > 0
    return a:cols_dt.'zl'
  elseif a:cols_dt < 0
    return -a:cols_dt.'zh'
  endif
endfunction
nnoremap <silent><expr> z\| <SID>horizontal_scroll(wincol() - (winwidth(0) / 2))

" save to <leader>;
noremap <silent> <leader><leader> :up<CR>
vnoremap <silent> <leader><leader> :<C-U>p<CR>gv

" save+quit to <leader>
noremap <silent> <leader>x :update \| q<CR>
vnoremap <silent> <leader>x :<C-U>update \| q<CR>

" quit/force-quit to <leader>q/Q
noremap <silent> <leader>q :q<CR>
vnoremap <silent> <leader>q :<C-U>q<CR>
noremap <silent> <leader>Q :q!<CR>
vnoremap <silent> <leader>Q :<C-U>q!<CR>

" bind arrows to pageup/pagedown, since I don't use them otherwise
function! s:scroll_half_screen(motion)
  return (winheight('$') / 2).a:motion
endfunction
nnoremap <silent><expr> <Down> <SID>scroll_half_screen('j')
nnoremap <silent><expr> <Up> <SID>scroll_half_screen('k')
vnoremap <silent><expr> <Down> <SID>scroll_half_screen('j')
vnoremap <silent><expr> <Up> <SID>scroll_half_screen('k')

if has('nvim')
  function! s:term_exit_scroll_up()
    return "\<C-\>\<C-n>".(winheight('$') / 2).'k'
  endfunction
  tnoremap <silent><expr> <C-u> <SID>term_exit_scroll_up()
endif

function! s:blackhole_paste(mode)
  if a:mode ==# 'char'
    let start_mark='`['
    let end_mark='`]'
  elseif index(['v', 'V'], a:mode) >= 0
    let start_mark='`<'
    let end_mark='`>'
  endif
  silent exec 'normal! '.start_mark
  let start_col=col('.')
  silent exec 'normal! v'.end_mark.'"bd'
  let end_col=col('.')
  if end_col < start_col  " happens when at end of line
    silent exec 'normal! p'
  else
    silent exec 'normal! P'
  endif
endfunction
function! s:blackhole_delete(mode)
  if a:mode ==# 'char'
    silent exec 'normal! `[v`]"bd'
  elseif index(['v', 'V'], a:mode) >= 0
    silent exec 'normal! `<v`>"bd'
  endif
endfunction
function! s:blackhole_bindings()
  if &ft =~ 'defx' | return | endif
  nnoremap <buffer><silent> mp :set operatorfunc=<SID>blackhole_paste<CR>g@
  vnoremap <buffer><silent> mp :<c-u>call <SID>blackhole_paste(visualmode())<CR>
  nnoremap <buffer><silent> md :set operatorfunc=<SID>blackhole_delete<CR>g@
  vnoremap <buffer><silent> md :<c-u>call <SID>blackhole_delete(visualmode())<CR>
  nnoremap <buffer><silent> mm "bdd
  nnoremap <buffer><silent> dp "bddP
endfunction
augroup blackhole_bindings
  autocmd!
  autocmd FileType * call s:blackhole_bindings()
augroup END

" directional split for files or new buffers
let g:saved_window_buffer_refs = {}
function! OpenDirectionalSplit(...) abort
  let g:last_direction_split = 0

  let file = ''
  if len(a:000) > 0
    let file = a:000[0]
    if file == 'NONE'
      let file = ''
    endif
  endif

  if len(a:000) > 1
    let dirchoice = a:000[1]
  else
    echohl Question
    echom 'Choose split direction. [hjklt or Enter] '
    echohl Normal
    call inputsave()
    let char = getchar()
    call inputrestore()
    redraw!
    if char == 27 " Esc
      return 0
    elseif char == 13  " Enter
      let dirchoice = 'e'
    else
      let dirchoice = nr2char(char)
    end
  end

  if !empty(file)
    let dirmap = {
          \ 'e': 'let g:saved_window_buffer_refs['.winnr().'] = '.bufnr('%').' | drop',
          \ 'h': 'aboveleft vsp | drop',
          \ 'j': 'belowright sp | drop',
          \ 'k': 'aboveleft sp | drop',
          \ 'l': 'belowright vsp | drop',
          \ 't': 'tabnew | drop',
          \ }
  else
    let dirmap = {
          \ 'e': 'let g:saved_window_buffer_refs['.winnr().'] = '.bufnr('%').' | edit',
          \ 'h': 'aboveleft vnew',
          \ 'j': 'belowright new',
          \ 'k': 'aboveleft new',
          \ 'l': 'belowright vnew',
          \ 't': 'tabnew',
          \ }
  endif

  let action = get(dirmap, dirchoice)
  if empty(action)
    echohl Error
    echom 'Unknown direction: '.dirchoice
    echohl Normal
  else
    let g:last_direction_split = dirchoice
    let cmd = join([action, file])
    exec cmd
    return 1
  endif
  return 0
endfunction
command! -bar -nargs=* DirectionalSplit call OpenDirectionalSplit(<f-args>)

" if we replace a file-backed buffer with a terminal, then switch back to that file when
" we quit from the terminal
if has('nvim')
  function! s:term_close_restore_previous_buffer(winnr)
    let saved_buffer = get(g:saved_window_buffer_refs, a:winnr, '')
    if !empty(saved_buffer)
      exec 'unlet g:saved_window_buffer_refs.'.a:winnr
      exec 'b '.saved_buffer
    else
      quit
    endif
  endfunction
  autocmd TermOpen * cnoremap <buffer><silent> q<CR> :call <SID>term_close_restore_previous_buffer(winnr())<CR>
endif

" vimrc and help
command! -nargs=? Vimrc DirectionalSplit $MYVIMRC <args>
cnoreabbrev vimrc Vimrc
command! Vimso source $MYVIMRC
cnoreabbrev vimso Vimso
command! -nargs=* -complete=help Vhelp vertical help <args>
cnoreabbrev vhelp Vhelp

" copy to xclip with Control-C
nnoremap <C-y> :w !xsel<CR><CR>
vnoremap <C-y> "*y

" remap indent to use single >/<
noremap > >>
noremap < <<

" reselects visual box after shift
vnoremap < <gv
vnoremap > >gv

" repeat macro in register q
nnoremap Q @q

" toggle fold more easily
nnoremap z<Space> za

" switching tabs
for i in range(0, 9)
  exec 'nnoremap <silent> t'.i.' '.i.'gt'
  exec 'nnoremap <silent> <A-'.i.'> '.i.'gt'
  exec 'vnoremap <silent> <A-'.i.'> '.i.'gt'
endfor

" command-line history
" set cedit=<C-R>

" paste in insert mode
" (depends on clipboard setting)
set pastetoggle=<F2>
inoremap <silent> <C-P> <F2><C-R>+<F2>

" get highlight group under cursor
" http://vim.wikia.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor
nnoremap <silent> <C-s> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
      \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
      \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" prettify JSON/XML
command! Prettify %!python -m json.tool

" source: http://stackoverflow.com/a/6271254
function! s:get_marker_selection(start_marker, end_marker)
  let [lnum1, col1] = getpos(a:start_marker)[1:2]
  let [lnum2, col2] = getpos(a:end_marker)[1:2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][col1 - 1:]
  return join(lines, '\n')
endfunction
function! s:get_visual_selection()
  return s:get_marker_selection("'<", "'>")
endfunction
function! s:get_operator_selection()
  return s:get_marker_selection("'[", "']")
endfunction

" search/replace visual selection
function! s:replace_selection(hasrange)
  if a:hasrange > 0
    call feedkeys(':%s/'.s:get_visual_selection().'/', 'm')
  endif
endfunction
command! -range=0 ReplaceSelection call s:replace_selection(<count>)
vnoremap <leader>r :ReplaceSelection<CR>

" kill any trailing whitespace on save (Credit to Facebook)
let g:strip_whitespace_blacklist = ['snippets']
function! s:strip_whitespace()
  let l = line(".")
  let c = col(".")
  %s/\s\+$//e
  call cursor(l, c)
endfunction
function! s:should_strip_whitespace()
  return index(g:strip_whitespace_blacklist, &ft) < 0 &&
              \ get(g:, 'strip_whitespace_pls', 1) &&
              \ &buftype !=# 'terminal'
endfunction
command! -bar -nargs=0 StripWhitespace call s:strip_whitespace()
augroup kill_whitespace_on_write
  autocmd!
  autocmd BufWritePre * if s:should_strip_whitespace() | StripWhitespace | endif
augroup END

" set buffer to unmodifiable if read-only
function! s:set_unmodifiable()
  if &readonly && &modifiable
    setlocal nomodifiable
  endif
endfu
augroup set_unmodifiable
  autocmd!
  autocmd BufReadPost * call s:set_unmodifiable()
augroup END

" 'zoom' into pane
function! s:break_to_tab()
  let bufnr = bufnr('%')
  let winnr = winnr()
  close
  exec 'tab new | b '.bufnr
endfunction
nnoremap <silent> <leader>z :call <SID>break_to_tab()<CR>

" vim-tmux aware killpane
function! TmuxAwareKillpane()
  if s:tmux || winnr('$') > 1
    silent :q
  else
    call system('tmux kill-pane')
  endif
endfunction
nmap <silent> <C-x> :call TmuxAwareKillpane()<CR>
" HACK: run this command in shell if vim-tmux-navigator isn't working in nvim
" $ infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\177/' > $TERM.ti
" $ tic $TERM.ti

" tmux pane title
function! s:xterm_title()
  let title=expand('%:t')
  return empty(title) ? '[No Name]' : title
endfunction
set title
augroup tmux_pane_title
  autocmd!
  autocmd BufReadPost,FileReadPost,BufNewFile,BufEnter *
        \ let &titlestring=s:xterm_title()
augroup END

" jump to tag
function! s:directional_tag(tag)
  let tselect_out = ''
  try
    redir => tselect_out
    silent exec 'tselect '.a:tag
    redir END
  catch /:E426/
    echohl Error
    echom "Tag '".a:tag."' not found!"
    return
  endtry

  let tag_cmd = len(split(tselect_out, '\n')) > 5 ? 'tselect' : 'tag'
  DirectionalSplit
  if !empty(g:last_direction_split)
    exec join([tag_cmd, a:tag])
  endif
endfunction
command! -nargs=1 Dtag call s:directional_tag(<f-args>)
nnoremap ts :exec 'Dtag '.expand('<cword>')<CR>
vnoremap <silent> ts :<C-U>exec 'Dtag '.<SID>get_visual_selection()<CR>

if has('nvim')
  " directional term splits
  command! -nargs=? Dterm DirectionalSplit term://$SHELL <args> | startinsert
  cnoreabbrev dt Dterm
  nnoremap <leader>d :Dterm<CR>
  for key in split('h j k l')
    exec 'cnoreabbrev dt'.key.' Dterm '.key
  endfor

  function! s:localdterm(...) abort
    let localdir = expand('%:p:h')
    if localdir =~ "^term://"
      let termpid = matchlist(localdir, 'term://.//\(\d\+\):')[1]
      let localdir = system("lsof -p ".termpid." | grep cwd | awk '{print $NF}' | xargs echo -n")
    endif
    if call('OpenDirectionalSplit', extend(['NONE'], a:000))
      exec 'lcd '.localdir
      term
    endif
  endfunction

  command! -nargs=? LDterm call s:localdterm(<f-args>)
  cnoreabbrev ldterm LDterm
  cnoreabbrev d. LDterm
  cnoreabbrev d, LDterm

  " terminal mappings
  tnoremap <silent> <C-w>h <C-\><C-n><C-w>h
  tnoremap <silent> <C-w>j <C-\><C-n><C-w>j
  tnoremap <silent> <C-w>k <C-\><C-n><C-w>k
  tnoremap <silent> <C-w>l <C-\><C-n><C-w>l
  tnoremap <silent> <C-h> <C-\><C-n>:TmuxNavigateLeft<CR>
  tnoremap <silent> <C-j> <C-\><C-n>:TmuxNavigateDown<CR>
  tnoremap <silent> <C-k> <C-\><C-n>:TmuxNavigateUp<CR>
  tnoremap <silent> <C-l> <C-\><C-n>:TmuxNavigateRight<CR>

  augroup term_autocmds
    autocmd!

    " escape terminal mappings
    autocmd TermOpen * tnoremap <buffer> <Esc><Esc> <C-\><C-n>
    autocmd FileType fzf tunmap <buffer> <Esc><Esc>

    " focus terminal automatically
    exec 'autocmd BufEnter term://$SHELL startinsert'
  augroup END
endif

command! ProfileStart profile start ~/temp/profile.log | profile func * | profile file *
command! ProfileDone profile pause | noautocmd qall!

command! PWD echo expand('%:p:h')

function! ToggleLocationList()
  if empty(filter(tabpagebuflist(), 'getbufvar(v:val, "&buftype") is# "quickfix"'))
    lwindow
  else
    lclose
  endif
endfunction
command! -nargs=0 ToggleLocationList call ToggleLocationList()
nnoremap <silent> <leader>1 :call ToggleLocationList()<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" tComment {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Use <leader>c to comment lines of code
nmap <leader>c :TComment<CR>
vmap <leader>c :TComment<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Lightline {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set laststatus=2   " Always show the statusline
if PlugLoaded('lightline.vim')
  let g:lightline = {
        \   'colorscheme': 'Tomorrow_Night',
        \   'active': {
        \     'left': [['mode', 'paste'], ['fileinfo', 'linter_checking', 'linter_errors', 'linter_warnings', 'linter_ok']],
        \     'right': [['lineinfo'], ['githead'], ['filetype']]
        \   },
        \   'inactive': {
        \     'left': [['fileinfo', 'syntax_status']],
        \     'right': [['lineinfo'], ['githead'], ['filetype']]
        \   },
        \   'component_function' : {
        \     'githead': 'GitHead',
        \     'mode': 'LLMode',
        \     'fileinfo': 'LLFileInfo',
        \     'lineinfo': 'LLLineInfo',
        \     'filetype': 'LLFileType',
        \   },
        \   'component_expand' : {
        \     'linter_checking': 'lightline#ale#checking',
        \     'linter_warnings': 'lightline#ale#warnings',
        \     'linter_errors': 'lightline#ale#errors',
        \     'linter_ok': 'lightline#ale#ok',
        \   },
        \   'component_type': {
        \     'linter_warnings': 'warning',
        \     'linter_errors': 'error',
        \   },
        \ }

  if PlugLoaded('ale')
    let g:lightline#ale#indicator_checking = s:WAIT
    let g:lightline#ale#indicator_warnings = s:W.' '
    let g:lightline#ale#indicator_errors = s:E.' '
    let g:lightline#ale#indicator_ok = s:OK
  endif

  function! GitHead()
    if index(['defx', 'fzf'], &ft) > -1 | return '' | endif
    let bufnr = bufnr('%')
    let git_head_ref = getbufvar(bufnr, 'git_head_ref')
    if empty(git_head_ref)
      let filedir = expand('#'.bufnr.':p:h')
      let head_branch = s:strip_trailing(system('git -C '.filedir.' rev-parse --abbrev-ref HEAD 2>/dev/null'))
      if empty(head_branch)
        let git_head_ref = 'no_git'
      else
        let git_head_ref = substitute(head_branch, '^aleks/', '', '')
      endif
      call setbufvar(bufnr, 'git_head_ref', git_head_ref)
    elseif git_head_ref == 'no_git'
      return ''
    endif
    return git_head_ref
  endfunction
  augroup reset_git_head
    autocmd!
    autocmd FocusGained * let b:git_head_ref = ''
  augroup END

  function! LLMode()
    let mode = get({
          \ 'defx': 'defx',
          \ 'fzf': 'FZF',
          \ 'peekaboo': 'peekaboo',
          \ }, &ft)
    if empty(mode)
      let mode = lightline#mode()
    endif
    return mode
  endfunction
  function! LLFileInfo()
    if index(['defx', 'fzf'], &ft) > -1 | return '' | endif
    let segments = [LLReadonly(), LLTrucatedFilePath(), LLModified()]
    return substitute(join(segments, ' '), '^\s*\(.\{-}\)\s*$', '\1', '')
  endfunction
  function! LLLineInfo()
    if index(['defx', 'fzf'], &ft) > -1 | return '' | endif
    let [_, l, c, _] = getpos('.')
    return l.':'.c
  endfunction
  function! LLFileType()
    if index(['defx', 'fzf'], &ft) > -1 | return '' | endif
    return &ft
  endfunction

  " filename and fileinfo
  let g:pathname_depth = 3
  function! LLModified()
    return index(['help', 'defx', 'peekaboo'], &ft) > -1 ? '' :
          \ &modified ? '+' : ''
  endfunction
  function! LLReadonly()
    return index(['help', 'defx', 'peekaboo'], &ft) < 0 && &readonly ? '🔒' : ''
  endfunction
  function! LLTrucatedFilePath()
    if index(['qf', 'defx', 'peekaboo'], &ft) > -1 | return '' | endif
    if &buftype ==# 'terminal' | return '' | endif
    let bufnr = bufnr('%')
    let buf_trunc_path = getbufvar(bufnr, 'trunc_path')
    if empty(buf_trunc_path)
      let filepath = expand('%:p')
      if filepath =~ '^fugitive'
        let fugitive_match = matchlist(filepath, '\.git//\([^/]\+\)/\(.*\)')
        let githash = fugitive_match[1][:8]
        call setbufvar(bufnr, 'git_head_ref', githash)
        let trunc_prefix = githash.':'
        let filepath = fugitive_match[2]
      else
        let trunc_prefix = ''
        let gitroot = s:gitroot(expand('%:h:p'))
        if !empty(gitroot)
          let split_filepath = split(expand('%:p'), gitroot)
          if empty(split_filepath)
            let gitroot = ''
            let filepath = ''
          else
            let filepath = split(expand('%:p'), gitroot)[0]
            let trunc_prefix = '$/'
          endif
        else
          let filepath = expand('%:p:~')
        endif
      endif

      echo filepath
      let buf_trunc_path = '[No Name]'
      if !empty(filepath)
        let path_parts = split(filepath, '/')
        let depth = -get(g:, 'pathname_depth', 3)
        let depth = depth < -len(path_parts) ? -len(path_parts) : depth
        let buf_trunc_path =
                    \ join(map(copy(path_parts[:depth-1]), "v:val[0].'/'"), '').
                    \ join(path_parts[depth:], '/')
        let buf_trunc_path = trunc_prefix.buf_trunc_path
      endif

      call setbufvar(bufnr, 'trunc_path', buf_trunc_path)
    endif
    return buf_trunc_path
  endfunction
  autocmd BufNewFile * unlet! b:trunc_path

  function! s:lightline_update_once_varargs(...)
    call lightline#update()
  endfunction
  function! s:lightline_update_once_delayed()
    if exists('s:lightline_cursormoved_timer')
      call timer_stop(s:lightline_cursormoved_timer)
    endif
    let s:lightline_cursormoved_timer =
          \ timer_start(100, function('s:lightline_update_once_varargs'))
  endfunction
  augroup lightline_timer_delayed
    autocmd!
    autocmd WinEnter,BufWinEnter,FileType,ColorScheme,SessionLoadPost * call lightline#update()
    autocmd ColorScheme,SessionLoadPost * call lightline#highlight()
    autocmd CursorMoved,BufUnload * call s:lightline_update_once_delayed()
    autocmd VimEnter * silent autocmd! lightline
  augroup END
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-easyalign {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('vim-easy-align')
  " Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
  vmap <Enter> <Plug>(EasyAlign)

  " Start interactive EasyAlign for a motion/text object (e.g. <leader>aip)
  nmap <leader>a <Plug>(EasyAlign)
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" a.vim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('a.vim')
  " toggle between .h and .c
  nnoremap <leader>a :A<CR>
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" deoplete {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('deoplete.nvim')
  let g:deoplete#enable_at_startup = 1

  imap <silent><expr> <Tab> pumvisible() ? "\<C-n>" : "<Tab>"
  imap <silent><expr> <S-Tab> pumvisible() ? "\<C-p>" : "<S-Tab>"

  let g:deoplete#file#enable_buffer_path = 1

  function! ToggleDeopleteF()
    let b:deoplete_disable_auto_complete=!get(b:, 'deoplete_disable_auto_complete', 0)
    echo 'Deoplete: '.!b:deoplete_disable_auto_complete
  endfunction
  command! -nargs=0 ToggleDeoplete call ToggleDeopleteF()
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" neosnippet {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('neosnippet.vim')
  let g:neosnippet#snippets_directory = $HOME.'/.vim/snippets'
  let g:neosnippet#disable_runtime_snippets = {
        \ '_': 1,
        \ } " disable built-in snippets

  " expand snippets with Enter
  " imap <silent><expr> <CR> neosnippet#expandable_or_jumpable() ?
  "       \ "\<Plug>(neosnippet_expand_or_jump)" : "\<CR>"
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Neomake {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('neomake')
  let g:neomake_verbose = 0 " useful for debug

  exec "highlight! NeomakeError ctermfg=red guifg=".GetHiKey('Error', 'guifg')
  exec "highlight! NeomakeWarning ctermfg=yellow guifg=".GetHiKey('Todo', 'guifg')

  let g:neomake_error_sign = {
        \ 'text': s:E,
        \ 'texthl': 'NeomakeError',
        \ }
  let g:neomake_warning_sign = {
        \ 'text': s:W,
        \ 'texthl': 'NeomakeWarning',
        \ }

  if executable('pylint')
    let g:neomake_python_enabled_makers = ['pylint']

    " let s:pylint_rcfile_path = '/Users/aleks/crowdai/inca/pylintrc'
    " let g:neomake_python_pylint_maker = neomake#makers#ft#python#pylint()
    " let g:neomake_python_pylint_maker.args += ['--rcfile='.s:pylint_rcfile_path]
  endif

  if executable('eslint')
    let g:neomake_javascript_enabled_makers = ['eslint']

    let s:eslint_rcfile_path = '/Users/aleks/crowdai/aztec_platform/.eslintrc.js'
    let g:neomake_javascript_eslint_maker = neomake#makers#ft#javascript#eslint()
    let g:neomake_javascript_eslint_maker.exe = '/Users/aleks/crowdai/aztec_platform/host_node_modules/node_modules/eslint/bin/eslint.js'
    let g:neomake_javascript_eslint_maker.args += ['-c', s:eslint_rcfile_path]
  endif

  if executable('npx')
    let g:neomake_typescript_enabled_makers = ['tslint']

    let s:tslint_config_path = '/Users/aleks/wize/wize/v2-frontend/tslint.json'
    let s:tslint_tsconfig_path = '/Users/aleks/wize/wize/v2-frontend/tsconfig.json'
    let g:neomake_typescript_tslint_maker = {
          \ 'errorformat': 'ERROR: %f:%l:%c - %m',
          \ }
    let g:neomake_typescript_tslint_maker.exe = 'npx'
    let g:neomake_typescript_tslint_maker.args = [
          \ 'tslint', '-c', s:tslint_config_path, '-p', s:tslint_tsconfig_path]
  endif

  let g:neomake_tex_enabled_makers = []

  function! ToggleNeomakeF()
    let b:neomake_enabled=!get(b:, 'neomake_enabled', 1)
    echo 'Neomake: '.b:neomake_enabled
  endfunction
  command! -nargs=0 ToggleNeomake call ToggleNeomakeF()

  function! NeomakeLightlineCallback(bufnr, callback_dict)
    if !a:callback_dict['has_next']
      call setbufvar(a:bufnr, 'neomake_running', 0)
      call lightline#update()
    endif
  endfunction

  " disable default neomake augroup
  function! s:disable_neomake_augroup()
    silent! autocmd! neomake
  endfunction

  function! s:after_write_neomake()
    if (!get(b:, 'goyo_enabled', 0) && get(b:, 'neomake_enabled', 1))
      let bufnr = bufnr('%')
      let neomake_jobs = neomake#Make(1, [], function("NeomakeLightlineCallback", [bufnr]))
      if !empty(neomake_jobs)
        exec 'sign unplace * buffer='.bufnr | exec 'sign place 9999 line=1 name=dummy buffer='.bufnr
        call setbufvar(bufnr, 'neomake_exists', 1)
        call setbufvar(bufnr, 'neomake_running', 1)
        call lightline#update()
      endif
    endif
  endfunction

  augroup postwrite_neomake
    autocmd!
    autocmd VimEnter * call s:disable_neomake_augroup()
    autocmd BufWritePost * call s:after_write_neomake()
  augroup END

  augroup neomake_cursor_moved
    autocmd!
    autocmd CursorMoved * call neomake#CursorMovedDelayed()
  augroup END
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" ale {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('ale')
  highlight! ALEWarning ctermbg=DarkMagenta
  highlight! ALEError ctermbg=DarkMagenta
  let g:ale_linters = {
        \ 'typescript': ['tsserver'],
        \ }

  let g:ale_sign_column_always = 1

  " only lint on file open and file save
  let g:ale_lint_on_text_changed = 'never'

  " show ale messages in quickfix list, not loclist
  " let g:ale_set_loclist = 0
  " let g:ale_set_quickfix = 1
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" neoformat {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" if executable('yapf')
"   let g:neoformat_python_yapf = neoformat#formatters#python#yapf()
"   let s:yapf_style_path = '/Users/aleks/crowdai/inca/style.yapf'
"   let g:neoformat_python_yapf.args = ['--style='.s:yapf_style_path]
"   let g:neoformat_enabled_python = ['yapf']
" endif

" if executable('npx')
"   let g:neoformat_typescript_prettier = neoformat#formatters#typescript#prettier()
"   let g:neoformat_typescript_prettier.exe = 'npx'
"   let g:neoformat_typescript_prettier.args = ['prettier'] + g:neoformat_typescript_prettier.args
"
"   augroup typescript_fmt
"     autocmd!
"     autocmd BufWritePre *.tsx,*.ts if !get(g:, 'disable_prettier', 0) | silent! undojoin | Neoformat | endif
"   augroup END
" endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" fzf {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('fzf')
  cnoreabbrev fzf FZF

  let g:fzf_action = {
        \ 'ctrl-t': 'tab split | drop',
        \ 'ctrl-x': 'split | drop',
        \ 'ctrl-v': 'vsplit | drop',
        \ 'ctrl-s': 'DirectionalSplit'
        \ }

  function! s:git_fzf(...) abort
    let from_dir = a:0 ? a:1 : '.'
    let gitroot = s:gitroot(from_dir)
    if empty(gitroot)
      FZF
    else
      exec 'FZF '.gitroot
    endif
  endfunction
  command! -nargs=? -bar GitFZF call s:git_fzf(<f-args>)

  nnoremap <silent> <leader>j :call <SID>git_fzf()<CR>
  nnoremap <silent> <leader>. :call <SID>git_fzf(expand('%:p:h'))<CR>
end

if PlugLoaded('fzf.vim')
  function! s:fzf(opts)
    call fzf#run(extend(fzf#vim#wrap(a:opts), fzf#vim#layout()))
  endfunction

  nnoremap <silent> <leader>t :Tags<CR>
  " NOTE: overrides EasyMotion f replacement
  nnoremap <silent> <leader>f :Buffers<CR>

  function! s:range_enabled_fzf_vim_ag(qargs, bang)
      let query = a:qargs
      if len(query) == 0
          let query = s:get_visual_selection()
      endif
      call fzf#vim#ag(query, a:bang)
  endfunction

  command! -range -bang -nargs=* Ag call s:range_enabled_fzf_vim_ag(<q-args>, <bang>0)
  cnoreabbrev ag Ag
  cnoreabbrev gs Ag

  function! s:selection_grep(mode)
    if a:mode ==# 'char'
      silent exec 'Ag '.s:get_operator_selection()
    elseif index(['v', 'V'], a:mode) >= 0
      silent exec 'Ag '.s:get_visual_selection()
    endif
  endfunction

  nnoremap <silent> gs :set operatorfunc=<SID>selection_grep<CR>g@
  vnoremap <silent> gs :<C-u>call <SID>selection_grep(visualmode())<CR>

  function! s:gitfiles_fzf()
    call s:fzf({
    \ 'source': 'git diff --name-only $(git merge-base HEAD master)',
    \ 'options': '--prompt "gf> "',
    \})
  endfunction
  nnoremap <silent> <leader>gf :call <SID>gitfiles_fzf()<CR>

  let g:fzf_nvim_statusline = 0
end

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-easymotion {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" enable easymotion with one leaderkey press
nmap <leader> <Plug>(easymotion-prefix)

" blue and green ayyy lmao
exec 'hi! EasyMotionTarget ctermfg=39 guifg='.RGBtoHex(26, 155, 252)
exec 'hi! EasyMotionTarget2First ctermfg=40 guifg='.RGBtoHex(31, 202, 35)
exec 'hi! EasyMotionTarget2Second ctermfg=28 guifg='.RGBtoHex(10, 101, 12)

" vim-easyoperator-line
let s:EasyOperator_line_do_mapping = 0
let s:EasyOperator_line_first = 'CursorLine'
omap <silent>  <leader>l <Plug>(easyoperator-line-select)
xmap <silent>  <leader>l <Plug>(easyoperator-line-select)
nmap <silent> d<leader>l <Plug>(easyoperator-line-delete)
nmap <silent> y<leader>l <Plug>(easyoperator-line-yank)

" vim-easymotion-segments
let g:EasyMotionSegments_key = 's'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" hop.nvim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TODO: configure this https://github.com/phaazon/hop.nvim

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Text Objects {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-textobj-user.vim
if PlugLoaded('vim-textobj-user')
  augroup TextobjUserSetup
    autocmd!
    autocmd BufEnter * call TextobjUserSetup()
  augroup END

  function! TextobjUserSetup()
    " textobj for current line
    " Copied from: https://github.com/kana/vim-textobj-user
    call textobj#user#plugin('line', {
          \   '-': {
          \     'select-a': 'al', 'select-a-function': 'TextobjCurrentLineA',
          \     'select-i': 'il', 'select-i-function': 'TextobjCurrentLineI',
          \   },
          \ })

    function! TextobjCurrentLineA()
      normal! 0
      let head_pos = getpos('.')
      normal! $
      let tail_pos = getpos('.')
      return ['v', head_pos, tail_pos]
    endfunction

    function! TextobjCurrentLineI()
      normal! ^
      let head_pos = getpos('.')
      normal! g_
      let tail_pos = getpos('.')
      let non_blank_char_exists_p = getline('.')[head_pos[2] - 1] !~# '\s'
      return
            \ non_blank_char_exists_p
            \ ? ['v', head_pos, tail_pos]
            \ : 0
    endfunction

    " textobj to turn foo_bar_baz into foo_baz *and* quuxSpamEggs into quuxEggs
    " Copied from: https://github.com/Julian/vim-textobj-variable-segment/blob/master/plugin/textobj/variable-segment.vim
    call textobj#user#plugin('variable', {
          \ '-': {
          \     'select-a': 'as',  'select-a-function': 'TextobjSelectSegmentA',
          \     'select-i': 'is',  'select-i-function': 'TextobjSelectSegmentI',
          \ }})

    function! TextobjSelectSegment(object_type, right_boundary)
      let left_boundaries = ['_\+\i', '\<', '\l\u', '\u\u\ze\l', '\a\d', '\d\a', '#\a']
      call search(join(left_boundaries, '\|'), 'bce')
      let start_position = getpos('.')

      call search('\>', 'c')
      let word_end = getpos('.')
      call setpos('.', start_position)

      call search(a:right_boundary, 'c')
      for _ in range(v:count1 - 1)
        if getpos('.') != word_end
          call search(a:right_boundary)
        endif
      endfor
      let end_position = getpos('.')

      return ['v', start_position, end_position]
    endfunction

    function! TextobjSelectSegmentA()
      let right_boundaries = ['_', '\l\u', '\u\u\l', '\a\d', '\d\a', '\i\>', '\a#']
      let right_boundary = join(right_boundaries, '\|')
      let [type, start_position, end_position] = TextobjSelectSegment('a', right_boundary)
      let [_, start_line, start_column, _] = start_position

      call search('\i\>', 'c')
      if end_position == getpos('.') &&
            \ getline(start_line)[start_column - 2] =~# '_'
        let start_position[2] -= 1
      endif

      let was_small_camel = match(expand('<cword>'), '^_*\l.*\u') != -1
      if was_small_camel
        call search('\<', 'bc')
        let [_, _, word_start, _] = getpos('.')

        if start_column - 2 <= word_start ||
              \ getline(start_line)[:start_column - 2] =~# '^_*$'
          call setpos('.', end_position)
          normal! l~
        endif
      endif

      return [type, start_position, end_position]
    endfunction

    function! TextobjSelectSegmentI()
      let right_boundaries = ['\i_', '\l\u', '\u\u\l', '\a\d', '\d\a', '\i\>', '\a#']
      return TextobjSelectSegment('i', join(right_boundaries, '\|'))
    endfunction

    " select entire file
    " Source: https://github.com/kana/vim-textobj-entire
    call textobj#user#plugin('entire', {
          \      '-': {
          \        '*sfile*': expand('<sfile>:p'),
          \        'select-a': 'ae',  '*select-a-function*': 'TextobjSelectEntireA',
          \        'select-i': 'ie',  '*select-i-function*': 'TextobjSelectEntireI'
          \      }
          \    })

    function! TextobjSelectEntireA()
      " To easily back to the last position after a command.
      " For example: yae<C-o>
      mark '

      keepjumps normal! gg0
      let start_pos = getpos('.')

      keepjumps normal! G$
      let end_pos = getpos('.')

      return ['V', start_pos, end_pos]
    endfunction

    function! TextobjSelectEntireI()
      " To easily back to the last position after a command.
      " For example: yie<C-o>
      mark '

      keepjumps normal! gg0
      call search('^.', 'cW')
      let start_pos = getpos('.')

      keepjumps normal! G$
      call search('^.', 'bcW')
      normal! $
      let end_pos = getpos('.')

      return ['V', start_pos, end_pos]
    endfunction
  endfunction
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" incsearch.vim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('incsearch.vim')
  set hlsearch
  let g:incsearch#auto_nohlsearch = 1
  map n  <Plug>(incsearch-nohl-n)
  map N  <Plug>(incsearch-nohl-N)
  map *  <Plug>(incsearch-nohl-*)
  map #  <Plug>(incsearch-nohl-#)
  map /  <Plug>(incsearch-forward)
  map ?  <Plug>(incsearch-backward)
  map g/ <Plug>(incsearch-stay)

  " stay on *
  map <silent> g* :let @/='\<'.expand('<cword>').'\>'<CR>
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Goyo {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" function! s:goyo_enter()
"   set noshowmode
"   set noshowcmd
"   let b:goyo_enabled = 1
"   let b:quitting = 0
"   let b:quitting_bang = 0
"   augroup goyo_quitpre
"     autocmd!
"     autocmd QuitPre <buffer> let b:quitting = 1
"   augroup END
"   cabbrev <buffer> q! let b:quitting_bang = 1 <bar> q!
" endfunction
"
" function! s:goyo_leave()
"   set showmode
"   set showcmd
"   let b:goyo_enabled = 0
"   " Quit Vim if this is the only remaining buffer
"   if b:quitting && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) == 1
"     if b:quitting_bang
"       qa!
"     else
"       qa
"     endif
"   endif
"   autocmd! goyo_quitpre
" endfunction
"
" augroup goyo
"   autocmd!
"   autocmd User GoyoEnter nested call <SID>goyo_enter()
"   autocmd User GoyoLeave nested call <SID>goyo_leave()
" augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" NERDTree {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('nerdtree')
  " let NERDTree hijack netrw while still having async load
  let g:NERDTreeHijackNetrw = 1
  function! s:plugasync_nerdtree_checkForBrowse(dir)
    silent! autocmd! FileExplorer
    if a:dir != '' && isdirectory(a:dir)
      if !exists('#NERDTree') | call plug#load('nerdtree') | endif
      call nerdtree#checkForBrowse(dir)
    endif
  endfunction
  augroup async_nerdtree
    autocmd!
    autocmd VimEnter * call s:plugasync_nerdtree_checkForBrowse(expand("<amatch>"))
  augroup END

  nnoremap <silent> <leader>k :NERDTreeFind<CR>
  nnoremap <silent> <leader>l :NERDTreeToggle<CR>

  let g:NERDTreeWinSize = 35
  let g:NERDTreeQuitOnOpen = 1

  " close Vim if NERDTree is the only window left
  augroup nerdtree_solo_close
    autocmd!
    autocmd BufEnter *
          \ if (winnr("$")==1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) |
          \ q |
          \ endif
  augroup END

  augroup nerdtree_unmap_mx
    autocmd!
    autocmd FileType nerdtree
                \| autocmd BufEnter * for x in ['m', 'd', 'p'] | exec 'unmap <buffer> m'.x | endfor
  augroup END
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Filetype {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" line wrap sucks for some files, but it's nice to choose the wrap width
function! s:manual_format(type, ...)
  let og_width = &textwidth
  let manual_width = get(b:, 'tw', -1)
  if manual_width == -1 | let manual_width = get(g:, 'tw', &textwidth) | endif
  exec 'set textwidth='.manual_width

  if a:0  " Invoked from Visual mode
    silent exe "normal! '<v'>gq"
  elseif a:type == 'line'
    silent exe "normal! '[V']gq"
  elseif a:type == 'block'
    silent exe "normal! '[\<C-V>']gq"
  else
    silent exe "normal! '[v']gq"
  endif

  exec 'set textwidth='.og_width
endfunction!

function! s:git_commit_ft()
  set textwidth=72
  set colorcolumn=71,72
  call matchaddpos('ColorColumn', [[1, 49, 2]])
endfunction

augroup vimrc_filetype
  autocmd!
  autocmd BufNewFile,BufReadPost *.ssc,*.scala set filetype=scala
  autocmd BufNewFile,BufReadPost *.md set filetype=markdown
  autocmd BufNewFile,BufReadPost Vagrantfile set filetype=ruby
  autocmd FileType c,cpp,vim,javascript,coffee,html,jinja setl sw=2 ts=2 sts=2 et
  autocmd BufNewFile,BufReadPost PULLREQ_EDITMSG set filetype=markdown.ghpull
  autocmd BufNewFile,BufReadPost COMMIT_EDITMSG call s:git_commit_ft()
  autocmd Filetype tex,markdown,markdown.ghpull,noft,text
        \ set wrap |
        \ set breakindent |
        \ set linebreak |
        \ set textwidth=9999 |
        \ exec 'nnoremap <silent> $ g$' |
        \ exec 'nnoremap <silent> ^ g^' |
        \ let b:tw = 119 |
        \ exec 'nnoremap <silent> gq :set opfunc=<SID>manual_format<CR>g@' |
        \ exec 'vnoremap <silent> gq :<C-U>call <SID>manual_format(visualmode(), 1)<CR>'
  autocmd FileType terraform,bash,sh
        \ set textwidth=9999
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Fugitive {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if get(g:, 'colors_name') == 'hybrid_ayk'
  hi! DiffAdd    guifg=NONE guibg=#1d2821
  hi! DiffChange guifg=NONE guibg=#1d1f34
  exec "hi! DiffDelete guifg=".GetHiKey('Normal', 'guibg')." guibg=#381f21"
  exec "hi! DiffText   guifg=".GetHiKey('Normal', 'guifg')." guibg=#1d1f60"
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" git commit through nvr {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! ForceBufDeleteCallback(bufnr, callback)
  exec 'bdelete! '.a:bufnr
endfunction
function! s:nvr_git_commit(commit_msg)
  exec 'split '.a:commit_msg |
        \ augroup git_commit_cleanup
            autocmd!
            autocmd BufWinLeave <buffer>
                  \ call system('touch '.expand('%:p:h').'/.nvr_finished_commit') |
                  \ call timer_start(1000, function('ForceBufDeleteCallback', [expand('<abuf>')]))
            " HACK ^
          augroup END
endfunction
command! -nargs=1 NvrGitCommit call <SID>nvr_git_commit(<f-args>)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" bracketed paste {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if !has('nvim')
  " Source: https://git.io/voxGp
  let &t_ti .= '\<Esc>[?2004h'
  let &t_te .= '\<Esc>[?2004l'

  function! XTermPasteBegin(ret)
    set pastetoggle=<f29>
    set paste
    return a:ret
  endfunction

  execute "set <f28>=\<Esc>[200~"
  execute "set <f29>=\<Esc>[201~"
  map <expr> <f28> XTermPasteBegin("i")
  imap <expr> <f28> XTermPasteBegin("")
  vmap <expr> <f28> XTermPasteBegin("c")
  cmap <f28> <nop>
  cmap <f29> <nop>
end
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-test {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if PlugLoaded('vim-test') && PlugLoaded('neoterm')
  let test#strategy = {
    \ 'nearest': 'neoterm',
    \ 'file':    'neoterm',
    \ 'suite':   'basic',
  \}
  command! -nargs=* -bar TN TestNearest <args>
  command! -nargs=* -bar TF TestFile <args>
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vimtex {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:vimtex_view_general_viewer = '/Applications/Skim.app/Contents/SharedSupport/displayline'
let g:vimtex_view_general_options = '-r @line @pdf @tex'
let g:vimtex_view_general_options_latexmk = '-r 1'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-python-pep8-indent {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:python_pep8_hanging_indent_width = 4

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-terraform {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:terraform_align=1

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" defx.nvim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! s:defx_directional_split()
  let file = defx#get_candidate().action__path
  return printf(":\<C-u>call defx#call_action('quit', []) | DirectionalSplit %s\<CR>", file)
endfunction
autocmd FileType defx call s:defx_settings()
function! s:defx_settings() abort
  " Define mappings
  nnoremap <silent><buffer><expr> q
  \ defx#do_action('quit')
  nnoremap <silent><buffer><expr> <CR>
  \ defx#is_directory() ?
  \ defx#do_action('open_or_close_tree') :
  \ defx#do_action('multi', ['drop', 'quit'])
  nnoremap <silent><buffer><expr> s
  \ defx#is_directory() ?
  \ defx#do_action('open_or_close_tree') :
  \ defx#do_action('multi', [['drop', 'vsplit'], 'quit'])
  nnoremap <silent><buffer><expr> i
  \ defx#is_directory() ?
  \ defx#do_action('open_or_close_tree') :
  \ defx#do_action('multi', [['drop', 'split'], 'quit'])
  nnoremap <silent><buffer><expr> <C-s>
  \ defx#is_directory() ?
  \ defx#do_action('open_or_close_tree') :
  \ <SID>defx_directional_split()
  nnoremap <silent><buffer><expr> c
  \ defx#do_action('copy')
  nnoremap <silent><buffer><expr> m
  \ defx#do_action('move')
  nnoremap <silent><buffer><expr> p
  \ defx#do_action('paste')
  nnoremap <silent><buffer><expr> E
  \ defx#do_action('open', 'vsplit')
  nnoremap <silent><buffer><expr> P
  \ defx#do_action('open', 'pedit')
  nnoremap <silent><buffer><expr> o
  \ defx#do_action('open_or_close_tree')
  nnoremap <silent><buffer><expr> a
  \ defx#do_action('new_file')
  nnoremap <silent><buffer><expr> C
  \ defx#do_action('toggle_columns',
  \                'mark:indent:icon:filename:type:size:time')
  nnoremap <silent><buffer><expr> S
  \ defx#do_action('toggle_sort', 'time')
  nnoremap <silent><buffer><expr> d
  \ defx#do_action('remove_trash')
  nnoremap <silent><buffer><expr> r
  \ defx#do_action('rename')
  nnoremap <silent><buffer><expr> yy
  \ defx#do_action('yank_path')
  nnoremap <silent><buffer><expr> .
  \ defx#do_action('toggle_ignored_files')
  nnoremap <silent><buffer><expr> ;
  \ defx#do_action('repeat')
  nnoremap <silent><buffer><expr> h
  \ defx#do_action('cd', ['..'])
  nnoremap <silent><buffer><expr> ~
  \ defx#do_action('cd')
  nnoremap <silent><buffer><expr> <Space>
  \ defx#do_action('toggle_select') . 'j'
  nnoremap <silent><buffer><expr> *
  \ defx#do_action('toggle_select_all')
  nnoremap <silent><buffer><expr> j
  \ line('.') == line('$') ? 'gg' : 'j'
  nnoremap <silent><buffer><expr> k
  \ line('.') == 1 ? 'G' : 'k'
  nnoremap <silent><buffer><expr> cd
  \ defx#do_action('change_vim_cwd')
  nnoremap <silent><buffer><expr> <C-r>
  \ defx#do_action('redraw')
endfunction

command! OpenDefxSplit Defx -search=`expand('%:p')` -split=vertical -winwidth=50 -direction=topleft -columns=mark:indent:icon:filename:type `getcwd()`
nnoremap <silent> <leader>k :OpenDefxSplit<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" coc.nvim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Use tab for trigger completion with characters ahead and navigate.
" Use command ':verbose imap <tab>' to make sure tab is not mapped by other plugin.
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current position.
" Coc only does snippet and additional edit on confirm.
inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() :
                                           \"\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

" Use `[c` and `]c` to navigate diagnostics
nmap <silent> [c <Plug>(coc-diagnostic-prev)
nmap <silent> ]c <Plug>(coc-diagnostic-next)

" Use K to show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Remap for rename current word
nmap <leader>rn <Plug>(coc-rename)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" alacritty {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" HACK: get cursor to show up on matching symbol
" (bug in alacritty: https://github.com/jwilm/alacritty/issues/2398)
hi! MatchParen ctermfg=234 ctermbg=60 guifg=#1d1f21 guibg=#5F5F87
hi! MatchParen term=reverse ctermfg=15 ctermbg=60 guifg=#c3c7c5 guibg=#5F5F87

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" MaxMEllon/vim-jsx-pretty {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:vim_jsx_pretty_highlight_close_tag = 1

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" markdown extra syntax {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
hi def MarkdownCheckboxStrikethrough cterm=strikethrough ctermfg=242
hi def MarkdownUnfocus ctermfg=242

augroup markdown_extra_syntax
  autocmd!
  autocmd Syntax markdown syn match MarkdownCheckboxStrikethrough /\(\s*\)\- \[x\]\_.\{-}\(\n\1-\)\@=/
  autocmd Syntax markdown syn match MarkdownUnfocus /\/\*\* HISTORY \*\*\/\_.*/
augroup END
